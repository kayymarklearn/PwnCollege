In this module, we will develop the skills needed to build a web server from scratch, starting with a simple program and progressing to handling multiple HTTP GET and POST requests.

SETUP:
	.intel_syntax noprefix
	.section .data
		.global _start
	.section .text
	_start:
		
		
1. Exit:
	`**SETUP**
		# EXIT syscall has number of 60
		mov rax, 60	# put the syscall descriptor in rax
		mov rdi, 0	# This takes the exit code as a parameter, 0 means success
		syscall		# asking the kernel to run the syscall
		
2. SOCKET:
	`**SETUP**
		# Socket is the endpoint for the server to communicate with devices and servcies that will connect to it
		# We use the Socket syscall (41) to create a socket. The socket syscall takes three key arguments
		# The domain (for example, AF_INET for IPv4), 
		# the type (such as SOCK_STREAM for TCP),
		# and the protocol (usually set to 0 to choose the default)
		
	THIS IS OUR CODE AFTER CREATING A SOCKET
		< .intel_syntax noprefix

		.section .data
			.global _start

			#socket details
			.equ    AF_INET, 2              # IPv4
			.equ    SOCK_STREAM, 1          # TCP
			.equ    INADDR_ANY, 0           # Any Address
			
			
		.section .text
		_start:

			# Creating a socket
			# socket(int domain, int type, int protocol)
			mov rax, 41             # socket syscall number for x86_64
			mov rdi, AF_INET        # domain = AF_INET (IPv4)
			mov rsi, SOCK_STREAM    # type = SOCK_STREAM (TCP)
			mov rdx, INADDR_ANY     # Protocol = INADDR_ANY (default)
			syscall

			# Simply exit the program
			mov rax, 60
			mov rdi, 0
			yscall >
3. BIND:
	After creating a socket, the next step is to assign it a network identity. In this challenge, you will use the bind syscall to connect your socket to a specific IP address and port number. The call requires you to provide the socket file descriptor, a pointer to a struct sockaddr (specifically a struct sockaddr_in for IPv4 that holds fields like the address family, port, and IP address), and the size of that structure. Binding is essential because it ensures your server listens on a known address, making it reachable by clients.
	
	THIS IS OUR CODE AFTER ASSIGNING A NETWORK IDENTITY:
		< .intel_syntax noprefix

		.section .data
			.global _start

			#socket details
			.equ    AF_INET, 2              # IPv4
			.equ    SOCK_STREAM, 1          # TCP

			
			sock_addr:
				.word 0x0002			# sin_family (AF_INET)
				.word 0x5000			# sin_port (Port 80 in network byte order (bg en))
				.long	0			# sin_addr (INADDR_ANY (0.0.0.0))
				.zero 8				# sin_zero padding
		.section .text
		_start:

			# Creating a socket
			# socket(int domain, int type, int protocol)
			mov rax, 41             # socket syscall number for x86_64
			mov rdi, AF_INET        # domain = AF_INET (IPv4)
			mov rsi, SOCK_STREAM    # type = SOCK_STREAM (TCP)
			mov rdx, 0		# Protocol = (default)
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# Save socket file descriptor
			mov rdi, r12		# store socket descriptor in r12 for use in Bind(), listen()
			
			
			# Calling Bind()
			# int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
			mov rax, 49		# bind syscall number
			mov rdi, r12		# r12 already contains socket descriptor
			lea rsi, [sock_addr]	# pointer to sock_addr structure
			mov rdx, 16		# size of sock_addr structure
			
			cmp rax, 0
			jl error_exit
			
			
			# exit cleanly
			mov rax, 60
			mov rdi, 0
			syscall
			
		error_exit:
			# Simply exit the program
			mov rax, 60
			mov rdi, 1
			syscall
		
		
4. LISTEN:
	With your socket bound to an address, you now need to prepare it to accept incoming connections. The listen syscall transforms your socket into a passive one that awaits client connection requests. It requires the socket’s file descriptor and a backlog parameter, which sets the maximum number of queued connections. This step is vital because without marking the socket as listening, your server wouldn’t be able to receive any connection attempts.
	
	THIS IS OUR CODE AFTER IMPLEMENTING LISTEN:
		< .intel_syntax noprefix

		.section .data
			.global _start

			#socket details
			.equ    AF_INET, 2              # IPv4
			.equ    SOCK_STREAM, 1          # TCP

			
			sock_addr:
				.word 0x0002			# sin_family (AF_INET)
				.word 0x5000			# sin_port (Port 80 in network byte order (bg en))
				.long	0			# sin_addr (INADDR_ANY (0.0.0.0))
				.zero 8				# sin_zero padding
		.section .text
		_start:

			# Creating a socket
			# socket(int domain, int type, int protocol)
			mov rax, 41             # socket syscall number for x86_64
			mov rdi, AF_INET        # domain = AF_INET (IPv4)
			mov rsi, SOCK_STREAM    # type = SOCK_STREAM (TCP)
			mov rdx, 0		# Protocol = (default)
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# Save socket file descriptor
			mov r12, rax		# store socket descriptor in r12 for use in other calls
			
			
			# Calling Bind()
			# int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
			mov rax, 49		# bind syscall number
			mov rdi, r12		# r12 already contains socket descriptor
			lea rsi, [sock_addr]	# pointer to sock_addr structure
			mov rdx, 16		# size of sock_addr structure
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# calling listen()
			# int listen(int sockfd, int backlog)
			mov rax, 50		# listen syscall number
			mov rdi, r12		# r12 already contains socket descriptor
			mov rsi, 0		# Using 0 as a placeholder
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			
			# exit cleanly
			mov rax, 60
			mov rdi, 0
			syscall
			
		error_exit:
			# Simply exit the program
			mov rax, 60
			mov rdi, 1
			syscall >


5. ACCEPT:
	Once your socket is listening, it’s time to actively accept incoming connections. In this challenge, you will use the accept syscall, which waits for a client to connect. When a connection is established, it returns a new socket file descriptor dedicated to communication with that client and fills in a provided address structure (such as a struct sockaddr_in) with the client’s details. This process is a critical step in transforming your server from a passive listener into an active communicator.
	
	AFTER IMPLEMENTING ACCEPT(), WE HAVE:
		
		< .intel_syntax noprefix

		.section .data
			.global _start

			#socket details
			.equ    AF_INET, 2              # IPv4
			.equ    SOCK_STREAM, 1          # TCP

			
			sock_addr:
				.word 0x0002			# sin_family (AF_INET)
				.word 0x5000			# sin_port (Port 80 in network byte order (bg en))
				.long	0			# sin_addr (INADDR_ANY (0.0.0.0))
				.zero 8				# sin_zero padding
		.section .bss
			client_addr:
				.zero 16			# space for sock_addr in structure
			client_addr_len:
				.quad 16			# length of address structure
				
		.section .text
		_start:

			# Creating a socket
			# socket(int domain, int type, int protocol)
			mov rax, 41             # socket syscall number for x86_64
			mov rdi, AF_INET        # domain = AF_INET (IPv4)
			mov rsi, SOCK_STREAM    # type = SOCK_STREAM (TCP)
			mov rdx, 0		# Protocol = (default)
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# Save socket file descriptor
			mov r12, rax		# store socket descriptor in r12 for use in other calls
			
			
			# Calling Bind()
			# int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
			mov rax, 49		# bind syscall number
			mov rdi, r12		# r12 already contains socket descriptor
			lea rsi, [sock_addr]	# pointer to sock_addr structure
			mov rdx, 16		# size of sock_addr structure
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# calling listen()
			# int listen(int sockfd, int backlog)
			mov rax, 50		# listen syscall number
			mov rdi, r12		# r12 already contains socket descriptor
			mov rsi, 0		# Using 0 as a placeholder
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# calling accept()
			# int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
			mov rax, 43			# syscall number for accept
			mov rdi, r12			# socket descriptor
			mov rsi, 0	#lea rsi, [client_addr]		# pointer to client address structure
			mov rdx, 0 #	lea rdx, [client_addr_len]	# pointer to address length
			sycall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# save client socket descriptor
			mov r13, rax			# store client socket descriptor in r13
			
			
			# calling close()
			# int close(int sockfd)
			# Close client socket when done
			mov rax, 3		# close syscall number
			mov rdi, r13		# client socket descriptor
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# exit cleanly
			mov rax, 60
			mov rdi, 0
			syscall
			
		error_exit:
			# Simply exit the program
			mov rax, 60
			mov rdi, 1
			syscall >


6. STATIC RESPONSE:
	Now that your server can establish connections, it’s time to learn how to send data. In this challenge, your goal is to send a fixed HTTP response (HTTP/1.0 200 OK\r\n\r\n) to any client that connects. You will use the write syscall, which requires a file descriptor, a pointer to a data buffer, and the number of bytes to write. This exercise is important because it teaches you how to format and deliver data over the network.
	
	BUILDING STATIC RESPONSE FUNCTIONALITY:
			
		< .intel_syntax noprefix

		.section .data
			.global _start

			#socket details
			.equ    AF_INET, 2              # IPv4
			.equ    SOCK_STREAM, 1          # TCP

			
			sock_addr:
				.word 0x0002			# sin_family (AF_INET)
				.word 0x5000			# sin_port (Port 80 in network byte order (bg en))
				.long	0			# sin_addr (INADDR_ANY (0.0.0.0))
				.zero 8				# sin_zero padding
		
			client_addr:
				.zero 16			# space for sock_addr in structure
			client_addr_len:
				.quad 16			# length of address structure
				
			# HTTP response data
			http_resp:
				.ascii "HTTP/1.0 200 OK\r\n\r\n"
			http_resp_len = . - http_resp
			
		.section .bss
			# Buffer for reading client request
			read_buffer:
				.zero 1024		# 1kb buffer for reading client data
				
		.section .text
		_start:

			# Creating a socket
			# socket(int domain, int type, int protocol)
			mov rax, 41             # socket syscall number for x86_64
			mov rdi, AF_INET        # domain = AF_INET (IPv4)
			mov rsi, SOCK_STREAM    # type = SOCK_STREAM (TCP)
			mov rdx, 0		# Protocol = (default)
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# Save socket file descriptor
			mov r12, rax		# store socket descriptor in r12 for use in other calls
			
			
			# Calling Bind()
			# int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
			mov rax, 49		# bind syscall number
			mov rdi, r12		# r12 already contains socket descriptor
			lea rsi, [sock_addr]	# pointer to sock_addr structure
			mov rdx, 16		# size of sock_addr structure
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# calling listen()
			# int listen(int sockfd, int backlog)
			mov rax, 50		# listen syscall number
			mov rdi, r12		# r12 already contains socket descriptor
			mov rsi, 0		# Using 0 as a placeholder
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# calling accept()
			# int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
			mov rax, 43			# syscall number for accept
			mov rdi, r12			# socket descriptor
			mov rsi, 0	#lea rsi, [client_addr]		# pointer to client address structure
			mov rdx, 0 #	lea rdx, [client_addr_len]	# pointer to address length
			sycall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# save client socket descriptor
			mov r13, rax			# store client socket descriptor in r13
			
			# Read client request
			# ssize_t read(int fd, void *buf, size_t count);
			mov rax, 0		# syscall for read
			mov rdi, r13		# client socked fd
			lea rsi, [read_buffer]	# buffer to store read data
			mov rdx, 1024		# read upto 1024 bytes (1kb)
			syscall
			
			# Error check [do not exit if no data, as this is normal]
			cmp rax, 0
			jl error_exit
			
			# Write HTTP response to client
			# ssize_t write(int fd, const void *buf, size_t count)
			
			mov rax, 1			# syscall number for write
			mov rdi, r13			# client socked fd
			lea rsi, [http_resp]		# pointer to HTTP response data
			mov rdx, http_resp_len		# length of HTTP response data
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			
			# calling close()
			# int close(int sockfd)
			# Close client socket when done
			mov rax, 3		# close syscall number
			mov rdi, r13		# client socket descriptor
			syscall
			
			# Error check
			cmp rax, 0
			jl error_exit
			
			# exit cleanly
			mov rax, 60
			mov rdi, 0
			syscall
			
		error_exit:
			# Simply exit the program
			mov rax, 60
			mov rdi, 1
			syscall >
		
		
7. DYNAMIC RESPONSES
	In this challenge, your server evolves to handle dynamic content based on HTTP GET requests. You will first use the read syscall to receive the incoming HTTP request from the client socket. By examining the request line--particularly, in this case, the URL path--you can determine what the client is asking for. Next, use the open syscall to open the requested file and read to read its contents. Send the file contents back to the client using the write syscall. This marks a significant step toward interactivity, as your server begins tailoring its output rather than simply echoing a static message.
	
	
	OUR SERVER NOW ACCEPTS DYNAMIC REQUESTS AND SENDS RESPONSES ACCORDINGLY:
			.intel_syntax noprefix

			.section .data
			    .global _start

			    #socket details
			    .equ    AF_INET, 2              # IPv4
			    .equ    SOCK_STREAM, 1          # TCP

			    sock_addr:
				    .word 0x0002            # sin_family (AF_INET)
				    .word 0x5000            # sin_port (port 80 in network byte order)
				    .long 0                 # sin_addr (INADDR_ANY)
				    .zero 8                 # sin_zero padding

			    client_addr:
				    .zero 16                # space for sock_addr
			    client_addr_len:
				    .quad 16                # length of address structure

			    # HTTP response headers
			    http_ok:
				    .ascii "HTTP/1.0 200 OK\r\n\r\n"
			    http_ok_len = . - http_ok
			    
			    http_not_found:
				    .ascii "HTTP/1.0 404 Not Found\r\n\r\n"
			    http_not_found_len = . - http_not_found

			    # Constants for string processing
			    get_method:
				    .ascii "GET "
			    get_method_len = . - get_method

			.section .bss
			    # Buffer for reading client request
			    read_buffer:
				    .zero 1024              # 1kb buffer
			    
			    # Buffer for file path
			    file_path:
				    .zero 1024              # buffer for file path
			    
			    # Buffer for file contents
			    file_buffer:
				    .zero 8192              # 8kb buffer

			.section .text
			_start:
			    # Create socket
			    mov rax, 41             # socket syscall
			    mov rdi, AF_INET        # IPv4
			    mov rsi, SOCK_STREAM    # TCP
			    mov rdx, 0              # default protocol
			    syscall
			    cmp rax, 0
			    jl error_exit
			    mov r12, rax            # save socket fd

			    # Bind socket
			    mov rax, 49             # bind syscall
			    mov rdi, r12            # socket fd
			    lea rsi, [sock_addr]    # address structure
			    mov rdx, 16             # structure size
			    syscall
			    cmp rax, 0
			    jl error_exit

			    # Listen
			    mov rax, 50             # listen syscall
			    mov rdi, r12            # socket fd
			    mov rsi, 0              # backlog
			    syscall
			    cmp rax, 0
			    jl error_exit

			    # Accept connection
			    mov rax, 43             # accept syscall
			    mov rdi, r12            # socket fd
			    mov rsi, 0              # client address
			    mov rdx, 0              # address length
			    syscall
			    cmp rax, 0
			    jl error_exit
			    mov r13, rax            # save client fd

			    # Read request
			    mov rax, 0              # read syscall
			    mov rdi, r13            # client fd
			    lea rsi, [read_buffer]  # buffer
			    mov rdx, 1024           # buffer size
			    syscall
			    cmp rax, 0
			    jl error_exit

			    # Check if GET request
			    lea rsi, [read_buffer]  # request data
			    lea rdi, [get_method]   # "GET " string
			    mov rcx, get_method_len # length to compare
			    repe cmpsb
			    jne send_not_found

			    # Find path start (after "GET ")
			    lea rsi, [read_buffer + get_method_len]
			    mov rcx, 1024 - get_method_len

			skip_spaces:
			    cmp byte ptr [rsi], ' '
			    jne found_path_start
			    inc rsi
			    loop skip_spaces
			    jmp send_not_found

			found_path_start:
			    # RSI now points to path start
			    lea rdi, [file_path]    # destination buffer
			    mov rbx, rdi            # save start of file_path

			copy_path:
			    cmp byte ptr [rsi], ' '  # end of path
			    je end_path_copy
			    cmp byte ptr [rsi], 0    # end of string
			    je end_path_copy
			    mov al, byte ptr [rsi]   # get current char
			    mov byte ptr [rdi], al   # store in file_path
			    inc rsi
			    inc rdi
			    jmp copy_path

			end_path_copy:
			    mov byte ptr [rdi], 0    # null-terminate

			    # Open file (use path exactly as provided)
			    mov rax, 2              # open syscall
			    mov rdi, rbx            # path to file
			    mov rsi, 0              # O_RDONLY
			    syscall
			    cmp rax, 0
			    jl send_not_found
			    mov r14, rax            # save file fd

			    # Read file
			    mov rax, 0              # read syscall
			    mov rdi, r14            # file fd
			    lea rsi, [file_buffer]  # buffer
			    mov rdx, 8192           # buffer size
			    syscall
			    mov r15, rax            # save bytes read

			    # Close file
			    mov rax, 3              # close syscall
			    mov rdi, r14            # file fd
			    syscall

			    # Send HTTP 200 OK header
			    mov rax, 1              # write syscall
			    mov rdi, r13            # client fd
			    lea rsi, [http_ok]      # response
			    mov rdx, http_ok_len    # length
			    syscall

			    # Send file contents
			    mov rax, 1              # write syscall
			    mov rdi, r13            # client fd
			    lea rsi, [file_buffer]  # file contents
			    mov rdx, r15            # length
			    syscall

			    jmp close_client

			send_not_found:
			    # Send 404 response
			    mov rax, 1              # write syscall
			    mov rdi, r13            # client fd
			    lea rsi, [http_not_found] # response
			    mov rdx, http_not_found_len # length
			    syscall

			close_client:
			    # Close client socket
			    mov rax, 3              # close syscall
			    mov rdi, r13            # client fd
			    syscall

			    # Exit cleanly
			    mov rax, 60
			    mov rdi, 0
			    syscall

			error_exit:
			    mov rax, 60
			    mov rdi, 1
			    syscall
			    
			    
8. ITERATIVE 'GET' SERVER:
	Previously, your server served just one GET request before terminating. Now, you will modify it so that it can handle multiple GET requests sequentially. This involves wrapping the accept-read-write-close sequence in a loop. Each time a client connects, your server will accept the connection, process the GET request, and then cleanly close the client session while remaining active for the next request. This iterative approach is essential for building a persistent server.
	
	NOW OUR SERVER HANDLES MULTIPLE GET REQUESTS SEQUENTIALLY:
			.intel_syntax noprefix

			.section .data
			    .global _start

			    #socket details
			    .equ    AF_INET, 2              # IPv4
			    .equ    SOCK_STREAM, 1          # TCP

			    sock_addr:
				    .word 0x0002            # sin_family (AF_INET)
				    .word 0x5000            # sin_port (port 80 in network byte order)
				    .long 0                 # sin_addr (INADDR_ANY)
				    .zero 8                 # sin_zero padding

			    client_addr:
				    .zero 16                # space for sock_addr
			    client_addr_len:
				    .quad 16                # length of address structure

			    # HTTP response headers
			    http_ok:
				    .ascii "HTTP/1.0 200 OK\r\n\r\n"
			    http_ok_len = . - http_ok
			    
			    http_not_found:
				    .ascii "HTTP/1.0 404 Not Found\r\n\r\n"
			    http_not_found_len = . - http_not_found

			    # Constants for string processing
			    get_method:
				    .ascii "GET "
			    get_method_len = . - get_method

			.section .bss
			    # Buffer for reading client request
			    read_buffer:
				    .zero 1024              # 1kb buffer
			    
			    # Buffer for file path
			    file_path:
				    .zero 1024              # buffer for file path
			    
			    # Buffer for file contents
			    file_buffer:
				    .zero 8192              # 8kb buffer

			.section .text

			_start:
			    # Create socket
			    mov rax, 41             # socket syscall
			    mov rdi, AF_INET        # IPv4
			    mov rsi, SOCK_STREAM    # TCP
			    mov rdx, 0              # default protocol
			    syscall
			    cmp rax, 0
			    jl error_exit
			    mov r12, rax            # save socket fd

			    # Bind socket
			    mov rax, 49             # bind syscall
			    mov rdi, r12            # socket fd
			    lea rsi, [sock_addr]    # address structure
			    mov rdx, 16             # structure size
			    syscall
			    cmp rax, 0
			    jl error_exit

			    # Listen
			    mov rax, 50             # listen syscall
			    mov rdi, r12            # socket fd
			    mov rsi, 0              # backlog
			    syscall
			    cmp rax, 0
			    jl error_exit

			server_loop:
			    # Accept connection
			    mov rax, 43             # accept syscall
			    mov rdi, r12            # socket fd
			    mov rsi, 0              # client address
			    mov rdx, 0              # address length
			    syscall
			    cmp rax, 0
			    jl error_exit
			    mov r13, rax            # save client fd

			    # Read request
			    mov rax, 0              # read syscall
			    mov rdi, r13            # client fd
			    lea rsi, [read_buffer]  # buffer
			    mov rdx, 1024           # buffer size
			    syscall
			    cmp rax, 0
			    jl close_client         # if read failed, just close client

			    # Check if GET request
			    lea rsi, [read_buffer]  # request data
			    lea rdi, [get_method]   # "GET " string
			    mov rcx, get_method_len # length to compare
			    repe cmpsb
			    jne send_not_found

			    # Find path start (after "GET ")
			    lea rsi, [read_buffer + get_method_len]
			    mov rcx, 1024 - get_method_len

			skip_spaces:
			    cmp byte ptr [rsi], ' '
			    jne found_path_start
			    inc rsi
			    loop skip_spaces
			    jmp send_not_found

			found_path_start:
			    # RSI now points to path start
			    lea rdi, [file_path]    # destination buffer
			    mov rbx, rdi            # save start of file_path

			copy_path:
			    cmp byte ptr [rsi], ' '  # end of path
			    je end_path_copy
			    cmp byte ptr [rsi], 0    # end of string
			    je end_path_copy
			    mov al, byte ptr [rsi]   # get current char
			    mov byte ptr [rdi], al   # store in file_path
			    inc rsi
			    inc rdi
			    jmp copy_path

			end_path_copy:
			    mov byte ptr [rdi], 0    # null-terminate

			    # Open file (use path exactly as provided)
			    mov rax, 2              # open syscall
			    mov rdi, rbx            # path to file
			    mov rsi, 0              # O_RDONLY
			    syscall
			    cmp rax, 0
			    jl send_not_found
			    mov r14, rax            # save file fd

			    # Read file
			    mov rax, 0              # read syscall
			    mov rdi, r14            # file fd
			    lea rsi, [file_buffer]  # buffer
			    mov rdx, 8192           # buffer size
			    syscall
			    mov r15, rax            # save bytes read

			    # Close file
			    mov rax, 3              # close syscall
			    mov rdi, r14            # file fd
			    syscall

			    # Send HTTP 200 OK header
			    mov rax, 1              # write syscall
			    mov rdi, r13            # client fd
			    lea rsi, [http_ok]      # response
			    mov rdx, http_ok_len    # length
			    syscall

			    # Send file contents
			    mov rax, 1              # write syscall
			    mov rdi, r13            # client fd
			    lea rsi, [file_buffer]  # file contents
			    mov rdx, r15            # length
			    syscall

			    jmp close_client

			send_not_found:
			    # Send 404 response
			    mov rax, 1              # write syscall
			    mov rdi, r13            # client fd
			    lea rsi, [http_not_found] # response
			    mov rdx, http_not_found_len # length
			    syscall

			close_client:
			    # Close client socket
			    mov rax, 3              # close syscall
			    mov rdi, r13            # client fd
			    syscall

			    # Go back to accept another client
			    jmp server_loop

			error_exit:
			    # Exit with error
			    mov rax, 60
			    mov rdi, 1
			    syscall
				
9. CONCURRENT 'GET' SERVER:
	To enable your server to handle several clients at once, you will introduce concurrency using the fork syscall. When a client connects, fork creates a child process dedicated to handling that connection. Meanwhile, the parent process immediately returns to accept additional connections. With this design, the child uses read and write to interact with the client, while the parent continues to listen. This concurrent model is a key concept in building scalable, real-world servers.
	
	OUR SERVER CAN NOW ACCEPT MULTIPLE REQUESTS USING CHILD PROCESSES:
		
		
		.intel_syntax noprefix

		.section .data
		    .global _start

		    # Socket details
		    .equ    AF_INET, 2              # IPv4
		    .equ    SOCK_STREAM, 1          # TCP

		    sock_addr:
			    .word 0x0002            # sin_family (AF_INET)
			    .word 0x5000            # sin_port (port 80 in network byte order)
			    .long 0                 # sin_addr (INADDR_ANY)
			    .zero 8                 # sin_zero padding

		    # HTTP response headers
		    http_ok:
			    .ascii "HTTP/1.0 200 OK\r\n\r\n"
		    http_ok_len = . - http_ok

		    http_not_found:
			    .ascii "HTTP/1.0 404 Not Found\r\n\r\n"
		    http_not_found_len = . - http_not_found

		    # Constants for string processing
		    get_method:
			    .ascii "GET "
		    get_method_len = . - get_method

		.section .bss
		    # Buffer for reading client request
		    read_buffer:
			    .zero 1024              # 1kb buffer

		    # Buffer for file path
		    file_path:
			    .zero 1024              # buffer for file path

		    # Buffer for file contents
		    file_buffer:
			    .zero 8192              # 8kb buffer

		.section .text

		_start:
		    # Create socket
		    mov rax, 41             # socket syscall
		    mov rdi, AF_INET        # IPv4
		    mov rsi, SOCK_STREAM    # TCP
		    mov rdx, 0              # default protocol
		    syscall
		    cmp rax, 0
		    jl error_exit
		    mov r12, rax            # save socket fd (should be 3)

		    # Bind socket
		    mov rax, 49             # bind syscall
		    mov rdi, r12            # socket fd
		    lea rsi, [sock_addr]    # address structure
		    mov rdx, 16             # structure size
		    syscall
		    cmp rax, 0
		    jl error_exit

		    # Listen
		    mov rax, 50             # listen syscall
		    mov rdi, r12            # socket fd
		    mov rsi, 0              # backlog
		    syscall
		    cmp rax, 0
		    jl error_exit

		server_loop:
		    # Accept connection with NULL, NULL
		    mov rax, 43             # accept syscall
		    mov rdi, r12            # socket fd
		    xor rsi, rsi            # NULL client addr
		    xor rdx, rdx            # NULL addrlen
		    syscall
		    cmp rax, 0
		    jl error_exit
		    mov r13, rax            # save client fd (should be 4)

		    # Fork
		    mov rax, 57             # fork syscall
		    syscall
		    cmp rax, 0
		    jl close_client         # fork failed, close client and retry
		    je child_process        # child process (rax == 0)

		    # Parent process
		    # Close client socket
		    mov rax, 3              # close syscall
		    mov rdi, r13            # client fd
		    syscall

		    # Go back to accept another client
		    jmp server_loop

		child_process:
		    # Child closes listening socket (fd 3)
		    mov rax, 3              # close syscall
		    mov rdi, r12            # listening socket fd
		    syscall

		    # Read request
		    mov rax, 0              # read syscall
		    mov rdi, r13            # client fd
		    lea rsi, [read_buffer]  # buffer
		    mov rdx, 1024           # buffer size
		    syscall
		    cmp rax, 0
		    jl close_and_exit       # if read failed, just close and exit

		    # Check if GET request
		    lea rsi, [read_buffer]  # request data
		    lea rdi, [get_method]   # "GET " string
		    mov rcx, get_method_len # length to compare
		    repe cmpsb
		    jne send_not_found

		    # Find path start (after "GET ")
		    lea rsi, [read_buffer + get_method_len]
		    mov rcx, 1024 - get_method_len

		skip_spaces:
		    cmp byte ptr [rsi], ' '
		    jne found_path_start
		    inc rsi
		    loop skip_spaces
		    jmp send_not_found

		found_path_start:
		    # RSI now points to path start
		    lea rdi, [file_path]    # destination buffer
		    mov rbx, rdi            # save start of file_path

		copy_path:
		    cmp byte ptr [rsi], ' '  # end of path
		    je end_path_copy
		    cmp byte ptr [rsi], 0    # end of string
		    je end_path_copy
		    mov al, byte ptr [rsi]   # get current char
		    mov byte ptr [rdi], al   # store in file_path
		    inc rsi
		    inc rdi
		    jmp copy_path

		end_path_copy:
		    mov byte ptr [rdi], 0    # null-terminate

		    # Open file
		    mov rax, 2              # open syscall
		    mov rdi, rbx            # path to file
		    mov rsi, 0              # O_RDONLY
		    syscall
		    cmp rax, 0
		    jl send_not_found
		    mov r14, rax            # save file fd (should be 3 now)

		    # Read file
		    mov rax, 0              # read syscall
		    mov rdi, r14            # file fd
		    lea rsi, [file_buffer]  # buffer
		    mov rdx, 8192           # buffer size
		    syscall
		    mov r15, rax            # save bytes read

		    # Close file fd 3
		    mov rax, 3              # close syscall
		    mov rdi, r14            # file fd
		    syscall

		    # Send HTTP 200 OK header
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [http_ok]      # response
		    mov rdx, http_ok_len    # length
		    syscall

		    # Send file contents
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [file_buffer]  # file contents
		    mov rdx, r15            # length
		    syscall

		    jmp close_and_exit

		send_not_found:
		    # Send 404 response
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [http_not_found] # response
		    mov rdx, http_not_found_len # length
		    syscall

		close_and_exit:
		    # Close client socket
		    mov rax, 3              # close syscall
		    mov rdi, r13            # client fd
		    syscall

		    # Exit child process
		    mov rax, 60             # exit syscall
		    xor rdi, rdi            # exit(0)
		    syscall

		close_client:
		    # Close client socket
		    mov rax, 3              # close syscall
		    mov rdi, r13            # client fd
		    syscall

		    # Go back to accept another client
		    jmp server_loop

		error_exit:
		    # Exit with error
		    mov rax, 60
		    mov rdi, 1
		    syscall
		    
		    
10. CONCURRENT 'POST' SERVER:
	OUR SERVER USED TO HANDLE ONLY 'GET' REQUESTS:
	NOW IT SHOULD HANDLE MULTIPLE 'POST' REQUESTS: like a real web server :) :)
		.intel_syntax noprefix

		.section .data
		    .global _start

		    # Socket details
		    .equ    AF_INET, 2              # IPv4
		    .equ    SOCK_STREAM, 1          # TCP

		    sock_addr:
			    .word 0x0002            # sin_family (AF_INET)
			    .word 0x5000            # sin_port (port 80 in network byte order)
			    .long 0                 # sin_addr (INADDR_ANY)
			    .zero 8                 # sin_zero padding

		    # HTTP response headers
		    http_ok:
			    .ascii "HTTP/1.0 200 OK\r\n\r\n"
		    http_ok_len = . - http_ok

		    http_not_found:
			    .ascii "HTTP/1.0 404 Not Found\r\n\r\n"
		    http_not_found_len = . - http_not_found

		    # Constants for string processing
		    get_method:
			    .ascii "GET "
		    get_method_len = . - get_method

		    post_method:
			    .ascii "POST "
		    post_method_len = . - post_method

		    header_end_marker:
			    .ascii "\r\n\r\n"
		    header_end_marker_len = . - header_end_marker

		.section .bss
		    # Buffer for reading client request
		    read_buffer:
			    .zero 4096              # 4kb buffer for larger POST requests

		    # Buffer for file path
		    file_path:
			    .zero 1024              # buffer for file path

		    # Buffer for file contents
		    file_buffer:
			    .zero 8192              # 8kb buffer

		.section .text

		_start:
		    # Create socket
		    mov rax, 41             # socket syscall
		    mov rdi, AF_INET        # IPv4
		    mov rsi, SOCK_STREAM    # TCP
		    mov rdx, 0              # default protocol
		    syscall
		    cmp rax, 0
		    jl error_exit
		    mov r12, rax            # save socket fd (should be 3)

		    # Bind socket
		    mov rax, 49             # bind syscall
		    mov rdi, r12            # socket fd
		    lea rsi, [sock_addr]    # address structure
		    mov rdx, 16             # structure size
		    syscall
		    cmp rax, 0
		    jl error_exit

		    # Listen
		    mov rax, 50             # listen syscall
		    mov rdi, r12            # socket fd
		    mov rsi, 0              # backlog
		    syscall
		    cmp rax, 0
		    jl error_exit

		server_loop:
		    # Accept connection with NULL, NULL
		    mov rax, 43             # accept syscall
		    mov rdi, r12            # socket fd
		    xor rsi, rsi            # NULL client addr
		    xor rdx, rdx            # NULL addrlen
		    syscall
		    cmp rax, 0
		    jl error_exit
		    mov r13, rax            # save client fd (should be 4)

		    # Fork
		    mov rax, 57             # fork syscall
		    syscall
		    cmp rax, 0
		    jl close_client         # fork failed, close client and retry
		    je child_process        # child process (rax == 0)

		    # Parent process
		    # Close client socket
		    mov rax, 3              # close syscall
		    mov rdi, r13            # client fd
		    syscall

		    # Go back to accept another client
		    jmp server_loop

		child_process:
		    # Child closes listening socket (fd 3)
		    mov rax, 3              # close syscall
		    mov rdi, r12            # listening socket fd
		    syscall

		    # Read request
		    mov rax, 0              # read syscall
		    mov rdi, r13            # client fd
		    lea rsi, [read_buffer]  # buffer
		    mov rdx, 4096           # increased buffer size
		    syscall
		    cmp rax, 0
		    jl close_and_exit       # if read failed, just close and exit
		    
		    # Save total request length
		    mov r14, rax            # total bytes read

		    # Check if GET request
		    lea rsi, [read_buffer]  # request data
		    lea rdi, [get_method]   # "GET " string
		    mov rcx, get_method_len # length to compare
		    repe cmpsb
		    jne check_post          # Not GET, check if POST
		    
		    # Handle GET request
		    lea rsi, [read_buffer + get_method_len]
		    jmp extract_path

		check_post:
		    # Check if POST request
		    lea rsi, [read_buffer]  # request data
		    lea rdi, [post_method]  # "POST " string
		    mov rcx, post_method_len # length to compare
		    repe cmpsb
		    jne send_not_found      # Neither GET nor POST
		    
		    # Handle POST request
		    lea rsi, [read_buffer + post_method_len]
		    jmp extract_path

		extract_path:
		    # RSI points to position after the method
		    # Extract path to file_path
		    mov rcx, 1024

		skip_spaces:
		    cmp byte ptr [rsi], ' '
		    jne found_path_start
		    inc rsi
		    loop skip_spaces
		    jmp send_not_found

		found_path_start:
		    # RSI now points to path start
		    lea rdi, [file_path]    # destination buffer
		    mov rbx, rdi            # save start of file_path

		copy_path:
		    cmp byte ptr [rsi], ' '  # end of path
		    je end_path_copy
		    cmp byte ptr [rsi], 0    # end of string
		    je end_path_copy
		    mov al, byte ptr [rsi]   # get current char
		    mov byte ptr [rdi], al   # store in file_path
		    inc rsi
		    inc rdi
		    jmp copy_path

		end_path_copy:
		    mov byte ptr [rdi], 0    # null-terminate

		    # Check if GET or POST
		    lea rsi, [read_buffer]
		    lea rdi, [get_method]
		    mov rcx, get_method_len
		    repe cmpsb
		    je handle_get           # It's a GET request
		    jmp handle_post         # Otherwise it's a POST request

		handle_get:
		    # Open file for reading
		    mov rax, 2              # open syscall
		    mov rdi, rbx            # path to file
		    mov rsi, 0              # O_RDONLY
		    syscall
		    cmp rax, 0
		    jl send_not_found
		    mov r14, rax            # save file fd

		    # Read file
		    mov rax, 0              # read syscall
		    mov rdi, r14            # file fd
		    lea rsi, [file_buffer]  # buffer
		    mov rdx, 8192           # buffer size
		    syscall
		    mov r15, rax            # save bytes read

		    # Close file fd
		    mov rax, 3              # close syscall
		    mov rdi, r14            # file fd
		    syscall

		    # Send HTTP 200 OK header
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [http_ok]      # response
		    mov rdx, http_ok_len    # length
		    syscall

		    # Send file contents
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [file_buffer]  # file contents
		    mov rdx, r15            # length
		    syscall

		    jmp close_and_exit

		handle_post:
		    # Find end of headers (\r\n\r\n)
		    xor rcx, rcx            # Initialize counter
		    lea rsi, [read_buffer]  # Start of request buffer

		find_headers_end:
		    cmp rcx, r14            # Check if we've reached end of request
		    jge send_not_found      # If yes, header end not found
		    
		    # Check for \r\n\r\n sequence
		    cmp byte ptr [rsi + rcx], 0x0D      # \r
		    jne continue_search
		    cmp byte ptr [rsi + rcx + 1], 0x0A  # \n
		    jne continue_search
		    cmp byte ptr [rsi + rcx + 2], 0x0D  # \r
		    jne continue_search
		    cmp byte ptr [rsi + rcx + 3], 0x0A  # \n
		    jne continue_search
		    
		    # Found header end
		    lea r8, [rsi + rcx + 4]  # R8 points to start of body
		    add rcx, 4               # Add marker length
		    mov r9, r14              # Total request length
		    sub r9, rcx              # Calculate body length (total - header_length)
		    jmp write_post_data
		    
		continue_search:
		    inc rcx
		    jmp find_headers_end
		    
		write_post_data:
		    # Open file for writing (create only)
		    mov rax, 2              # open syscall
		    mov rdi, rbx            # path to file
		    mov rsi, 0x41           # O_WRONLY | O_CREAT (0x41 = 65 decimal)
		    mov rdx, 0777           # File permissions (octal 777)
		    syscall
		    cmp rax, 0
		    jl send_not_found
		    mov r15, rax            # save file fd
		    
		    # Write POST data to file
		    mov rax, 1              # write syscall
		    mov rdi, r15            # file fd
		    mov rsi, r8             # body data pointer
		    mov rdx, r9             # body length
		    syscall
		    
		    # Close file
		    mov rax, 3              # close syscall
		    mov rdi, r15            # file fd
		    syscall
		    
		    # Send HTTP 200 OK response
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [http_ok]      # response
		    mov rdx, http_ok_len    # length
		    syscall
		    
		    jmp close_and_exit

		send_not_found:
		    # Send 404 response
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [http_not_found] # response
		    mov rdx, http_not_found_len # length
		    syscall

		close_and_exit:
		    # Close client socket
		    mov rax, 3              # close syscall
		    mov rdi, r13            # client fd
		    syscall

		    # Exit child process
		    mov rax, 60             # exit syscall
		    xor rdi, rdi            # exit(0)
		    syscall

		close_client:
		    # Close client socket
		    mov rax, 3              # close syscall
		    mov rdi, r13            # client fd
		    syscall

		    # Go back to accept another client
		    jmp server_loop

		error_exit:
		    # Exit with error
		    mov rax, 60
		    mov rdi, 1
		    syscall
		   
		   
11. WEB SERVER [finally :)]:
	In the final challenge, your server must seamlessly support both GET and POST requests within a single program. After reading the incoming request using read, your server will inspect the first few characters to determine whether it is dealing with a GET or a POST. Depending on the request type, it will process the data accordingly and then send back an appropriate response using write. Throughout this process, fork is employed to handle each connection concurrently, ensuring that your server can manage multiple requests at the same time. After completing this, you will have built a simple, but fully functional, web server capable of handling different types of HTTP requests.
	
	FINISHED AND FUNCTIONAL WEB SERVER [whew]:
		<.intel_syntax noprefix

		.section .data
		    .global _start

		    # Socket details
		    .equ    AF_INET, 2              # IPv4
		    .equ    SOCK_STREAM, 1          # TCP

		    sock_addr:
			    .word 0x0002            # sin_family (AF_INET)
			    .word 0x5000            # sin_port (port 80 in network byte order)
			    .long 0                 # sin_addr (INADDR_ANY)
			    .zero 8                 # sin_zero padding

		    # HTTP response headers
		    http_ok:
			    .ascii "HTTP/1.0 200 OK\r\n\r\n"
		    http_ok_len = . - http_ok

		    http_not_found:
			    .ascii "HTTP/1.0 404 Not Found\r\n\r\n"
		    http_not_found_len = . - http_not_found

		    # Constants for string processing
		    get_method:
			    .ascii "GET "
		    get_method_len = . - get_method

		    post_method:
			    .ascii "POST "
		    post_method_len = . - post_method

		    header_end_marker:
			    .ascii "\r\n\r\n"
		    header_end_marker_len = . - header_end_marker

		.section .bss
		    # Buffer for reading client request
		    read_buffer:
			    .zero 4096              # 4kb buffer for larger POST requests

		    # Buffer for file path
		    file_path:
			    .zero 1024              # buffer for file path

		    # Buffer for file contents
		    file_buffer:
			    .zero 8192              # 8kb buffer

		.section .text

		_start:
		    # Create socket
		    mov rax, 41             # socket syscall
		    mov rdi, AF_INET        # IPv4
		    mov rsi, SOCK_STREAM    # TCP
		    mov rdx, 0              # default protocol
		    syscall
		    cmp rax, 0
		    jl error_exit
		    mov r12, rax            # save socket fd (should be 3)

		    # Bind socket
		    mov rax, 49             # bind syscall
		    mov rdi, r12            # socket fd
		    lea rsi, [sock_addr]    # address structure
		    mov rdx, 16             # structure size
		    syscall
		    cmp rax, 0
		    jl error_exit

		    # Listen
		    mov rax, 50             # listen syscall
		    mov rdi, r12            # socket fd
		    mov rsi, 0              # backlog
		    syscall
		    cmp rax, 0
		    jl error_exit

		server_loop:
		    # Accept connection with NULL, NULL
		    mov rax, 43             # accept syscall
		    mov rdi, r12            # socket fd
		    xor rsi, rsi            # NULL client addr
		    xor rdx, rdx            # NULL addrlen
		    syscall
		    cmp rax, 0
		    jl error_exit
		    mov r13, rax            # save client fd (should be 4)

		    # Fork
		    mov rax, 57             # fork syscall
		    syscall
		    cmp rax, 0
		    jl close_client         # fork failed, close client and retry
		    je child_process        # child process (rax == 0)

		    # Parent process
		    # Close client socket
		    mov rax, 3              # close syscall
		    mov rdi, r13            # client fd
		    syscall

		    # Go back to accept another client
		    jmp server_loop

		child_process:
		    # Child closes listening socket (fd 3)
		    mov rax, 3              # close syscall
		    mov rdi, r12            # listening socket fd
		    syscall

		    # Read request
		    mov rax, 0              # read syscall
		    mov rdi, r13            # client fd
		    lea rsi, [read_buffer]  # buffer
		    mov rdx, 4096           # increased buffer size
		    syscall
		    cmp rax, 0
		    jl close_and_exit       # if read failed, just close and exit
		    
		    # Save total request length
		    mov r14, rax            # total bytes read

		    # Check if GET request
		    lea rsi, [read_buffer]  # request data
		    lea rdi, [get_method]   # "GET " string
		    mov rcx, get_method_len # length to compare
		    repe cmpsb
		    jne check_post          # Not GET, check if POST
		    
		    # Handle GET request
		    lea rsi, [read_buffer + get_method_len]
		    jmp extract_path

		check_post:
		    # Check if POST request
		    lea rsi, [read_buffer]  # request data
		    lea rdi, [post_method]  # "POST " string
		    mov rcx, post_method_len # length to compare
		    repe cmpsb
		    jne send_not_found      # Neither GET nor POST
		    
		    # Handle POST request
		    lea rsi, [read_buffer + post_method_len]
		    jmp extract_path

		extract_path:
		    # RSI points to position after the method
		    # Extract path to file_path
		    mov rcx, 1024

		skip_spaces:
		    cmp byte ptr [rsi], ' '
		    jne found_path_start
		    inc rsi
		    loop skip_spaces
		    jmp send_not_found

		found_path_start:
		    # RSI now points to path start
		    lea rdi, [file_path]    # destination buffer
		    mov rbx, rdi            # save start of file_path

		copy_path:
		    cmp byte ptr [rsi], ' '  # end of path
		    je end_path_copy
		    cmp byte ptr [rsi], 0    # end of string
		    je end_path_copy
		    mov al, byte ptr [rsi]   # get current char
		    mov byte ptr [rdi], al   # store in file_path
		    inc rsi
		    inc rdi
		    jmp copy_path

		end_path_copy:
		    mov byte ptr [rdi], 0    # null-terminate

		    # Check if GET or POST
		    lea rsi, [read_buffer]
		    lea rdi, [get_method]
		    mov rcx, get_method_len
		    repe cmpsb
		    je handle_get           # It's a GET request
		    jmp handle_post         # Otherwise it's a POST request

		handle_get:
		    # Open file for reading
		    mov rax, 2              # open syscall
		    mov rdi, rbx            # path to file
		    mov rsi, 0              # O_RDONLY
		    syscall
		    cmp rax, 0
		    jl send_not_found
		    mov r14, rax            # save file fd

		    # Read file
		    mov rax, 0              # read syscall
		    mov rdi, r14            # file fd
		    lea rsi, [file_buffer]  # buffer
		    mov rdx, 8192           # buffer size
		    syscall
		    mov r15, rax            # save bytes read

		    # Close file fd
		    mov rax, 3              # close syscall
		    mov rdi, r14            # file fd
		    syscall

		    # Send HTTP 200 OK header
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [http_ok]      # response
		    mov rdx, http_ok_len    # length
		    syscall

		    # Send file contents
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [file_buffer]  # file contents
		    mov rdx, r15            # length
		    syscall

		    jmp close_and_exit

		handle_post:
		    # Find end of headers (\r\n\r\n)
		    xor rcx, rcx            # Initialize counter
		    lea rsi, [read_buffer]  # Start of request buffer

		find_headers_end:
		    cmp rcx, r14            # Check if we've reached end of request
		    jge send_not_found      # If yes, header end not found
		    
		    # Check for \r\n\r\n sequence
		    cmp byte ptr [rsi + rcx], 0x0D      # \r
		    jne continue_search
		    cmp byte ptr [rsi + rcx + 1], 0x0A  # \n
		    jne continue_search
		    cmp byte ptr [rsi + rcx + 2], 0x0D  # \r
		    jne continue_search
		    cmp byte ptr [rsi + rcx + 3], 0x0A  # \n
		    jne continue_search
		    
		    # Found header end
		    lea r8, [rsi + rcx + 4]  # R8 points to start of body
		    add rcx, 4               # Add marker length
		    mov r9, r14              # Total request length
		    sub r9, rcx              # Calculate body length (total - header_length)
		    jmp write_post_data
		    
		continue_search:
		    inc rcx
		    jmp find_headers_end
		    
		write_post_data:
		    # Open file for writing (create only)
		    mov rax, 2              # open syscall
		    mov rdi, rbx            # path to file
		    mov rsi, 0x41           # O_WRONLY | O_CREAT (0x41 = 65 decimal)
		    mov rdx, 0777           # File permissions (octal 777)
		    syscall
		    cmp rax, 0
		    jl send_not_found
		    mov r15, rax            # save file fd
		    
		    # Write POST data to file
		    mov rax, 1              # write syscall
		    mov rdi, r15            # file fd
		    mov rsi, r8             # body data pointer
		    mov rdx, r9             # body length
		    syscall
		    
		    # Close file
		    mov rax, 3              # close syscall
		    mov rdi, r15            # file fd
		    syscall
		    
		    # Send HTTP 200 OK response
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [http_ok]      # response
		    mov rdx, http_ok_len    # length
		    syscall
		    
		    jmp close_and_exit

		send_not_found:
		    # Send 404 response
		    mov rax, 1              # write syscall
		    mov rdi, r13            # client fd
		    lea rsi, [http_not_found] # response
		    mov rdx, http_not_found_len # length
		    syscall

		close_and_exit:
		    # Close client socket
		    mov rax, 3              # close syscall
		    mov rdi, r13            # client fd
		    syscall

		    # Exit child process
		    mov rax, 60             # exit syscall
		    xor rdi, rdi            # exit(0)
		    syscall

		close_client:
		    # Close client socket
		    mov rax, 3              # close syscall
		    mov rdi, r13            # client fd
		    syscall

		    # Go back to accept another client
		    jmp server_loop

		error_exit:
		    # Exit with error
		    mov rax, 60
		    mov rdi, 1
		    syscall >
				

				
