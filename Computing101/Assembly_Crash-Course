Now that you have the hang of very basic assembly, let's dive in and explore a few different instructions and some additional concepts! The Assembly Crash Course is a romp through a lot of different things you can do in assembly.

We will be using intel syntax for all our assembly code, so always use this prefix before your code;
	.intel_syntax noprefix
	.global _start
	_start:
	
We will assemble our code with;
	gcc -nostdlib -o prog prog.s
	
The program can be run with;
	./prog
after compilation.

You can disassemble your program with;
	objdump -M intel -d prog
	
Now to the challenges;

1. Set-register;
	Task: set the register, rdi to 0x1337
	Solution:
		`.intel_syntax noprefix

		.global _start

		_start:
		mov rdi, 0x1337 `

2. Set-multiple-registers:
	Task: Set the registers to the following;
		
    		rax = 0x1337
   		r12 = 0xCAFED00D1337BEEF
    		rsp = 0x31337

	Solution:
		`.intel_syntax noprefix
		.global _start

		_start:
		mov rax, 0x1337
		mov r12, 0xCAFED00D1337BEEF
		mov rsp, 0x31337 `
		
Let's learn some useful instructions before tackling the next challenges:
	a. add reg1, reg2 <=> reg1 += reg2 <=> reg1 = reg1 + reg2	# add 2 registers
	b. sub reg1, reg2 <=> reg1 -= reg2 <=> reg1 = reg1 - reg2	# sub 2 registers
	c. imul reg1, reg2 <=> reg1 *= reg2 <=> reg1 = reg1 * reg2 	# mul 2 registers
	NOTE: regX, can be replaced by a constant or a mem location, div is more complicated and will be discussed later.
With this knowledge, we'll tackle the next challenges.

3. add-to-registers
	Task: Add 0x331337 to rdi
	Solution:
		` .intel_syntax noprefix
		.global _start

		_start:

		add rdi, 0x331337`
		
4. linear-equation-registers
	Task: Compute, f(x) = mx + b, where;
		m = rdi, x = rsi, b = rdx
	
	Solution:
		`.intel_syntax noprefix
		.global _start

		_start:
		imul rdi, rsi
		add rdi, rdx
		mov rax, rdi `

DIVISION in x86 is more special than in normal math. Math here is called integer math, meaning every value is a whole number.
As an example: 10 / 3 = 3 in integer math.

Why?

Because 3.33 is rounded down to an integer.

The relevant instructions for this level are:

    mov rax, reg1
    div reg2

NOTE: div is a special instruction that can divide a 128-bit dividend by a 64-bit divisor while storing both the quotient and the remainder, using only one register as an operand.

How does this complex div instruction work and operate on a 128-bit dividend (which is twice as large as a register)?

For the instruction div reg, the following happens:

    rax = rdx:rax / reg
    rdx = remainder

rdx:rax means that rdx will be the upper 64-bits of the 128-bit dividend and rax will be the lower 64-bits of the 128-bit dividend.

You must be careful about what is in rdx and rax before you call div.

5. integer-division:
	Task:
		Compute the following:

    		speed = distance / time, where:
        	distance = rdi
        	time = rsi
        	speed = rax
        
        Solution:
        	`.intel_syntax noprefix
		.global _start

		_start:
		mov rax, rdi		# mov numerator (distance) into rax
		xor rdx, rdx		# clear rdx to prepare for division (upper 64 bits)
		div rsi`		# unsigned divide rdx:rax by rsi
		
		REMEMBER: Quotient (speed here) is in rax, remainder is in rdx.

6. modulo operation:
	Modulo is basically the remainder of a division operation.
	So 10 % 3, will return 1 (where % is the modulo operator).
	Note that the remainder of the div operation in x86 is stored in rdx.
	
	Task:
		Compute the following: rdi % rsi
		Place the value in rax.
	
	Solution:
		`.intel_syntax noprefix
		.global _start
		
		_start:
			mov rax, rdi
			xor rdx, rdx
			div rsi
			
			mov rax, rdx`	# Placing the remainder (which is in rdx) into rax.
			
7. set-upper-byte:
	Each register in x86_64 is 64 bits in size. 
	We can also access the lower bytes of each register using different register names.
	For example, the lower 32 bits of rax can be accessed using eax, the lower 16 bits using ax, and the lower 8 bits using al.

	MSB                                    LSB
	+----------------------------------------+
	|                   rax                  |
	+--------------------+-------------------+
		             |        eax        |
		             +---------+---------+
		                       |   ax    |
		                       +----+----+
		                       | ah | al |
		                       +----+----+

	Task:
		Using only one move instruction, please set the upper 8 bits of the ax register to 0x42.
		
	Solution:
		`.intel_syntax noprefix
		.global _start
		
		_start:
			mov ah, 0x42 # ax is a 32bit reg that has ah as upper bit and al as lower bit
			
8. Efficient modulo:
	We can use a math trick to optimize the modulo operator (%). Compilers use this trick a lot.

	If we have x % y, and y is a power of 2, such as 2^n, the result will be the lower n bits of x.

	Therefore, we can use the lower register byte access to efficiently implement modulo!
	
	Task:
		Compute the following:

		    rax = rdi % 256
		    rbx = rsi % 65536
		    
	Solution:
		`.intel_syntax noprefix
		.global _start

		mov rax, 0
		mov al, dil	; rax = rdi % 256, 256 = 2^8, so we move lowest 8 bit of rdi (dil) to al (lowest 8 bit of rax)
		
		mov rbx, 0
		mov bx, si	; rbx = rsi % 65536, 65536 = 2 ^16, so we move the lowest 16 bits.
		`

9. Byte-Extraction:
	
	IMPORTANT INFO:
		Shifting bits around in assembly is another interesting concept!

		x86 allows you to 'shift' bits around in a register.

		Take, for instance, al, the lowest 8 bits of rax.

		The value in al (in bits) is:

		rax = 10001010

		If we shift once to the left using the shl instruction:

		shl al, 1

		The new value is:

		al = 00010100

		Everything shifted to the left, and the highest bit fell off while a new 0 was added to the right side.

		You can use this to do special things to the bits you care about.

		Shifting has the nice side effect of doing quick multiplication (by 2) or division (by 2), and can also be used to compute modulo.	
		
		
		Here are the important instructions:

		    shl reg1, reg2 <=> Shift reg1 left by the amount in reg2
		    shr reg1, reg2 <=> Shift reg1 right by the amount in reg2
		    
	Task:
		Set rax to the 5th least significant byte of rdi.

		For example:

		rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |
		Set rax to the value of B4
		
	Solution:
		`.intel_syntax noprefix
		.global _start
		
		_start:
			mov rax, rdi
			shr rax, 32
			shl rax, 56
			shr rax, 56
			
		'

Bitwise logic, performs comparisions between individual bits.
Here are some truth tables for reference:

    AND

    A | B | X
    ---+---+---
    0 | 0 | 0
    0 | 1 | 0
    1 | 0 | 0
    1 | 1 | 1

    OR

    A | B | X
    ---+---+---
    0 | 0 | 0
    0 | 1 | 1
    1 | 0 | 1
    1 | 1 | 1

    XOR

    A | B | X
    ---+---+---
    0 | 0 | 0
    0 | 1 | 1
    1 | 0 | 1
    1 | 1 | 0


10. Bitwise-and
	Task:
		Without using the following instructions: mov, xchg, please perform the following:

		Set rax to the value of (rdi AND rsi)
	
	Solution:
		`..............
		.............
		
		_start:
			push rdi	; push rdi into the stack
			pop rax		; pop the value of rdi onto rax
			and rax, rsi
			`
			
11. Check-even:
	Task:	
		Using only the following instructions:

		    and
		    or
		    xor

		Implement the following logic:

		if x is even then
		  y = 1
		else
		  y = 0

		Where:
		    x = rdi
	   	    y = rax
	   
	Solution:
		`...............
		................
		
		_start:
			and rdi, 1	; Extract the least significant bit of rdi
			xor rdi, 1	; Flip the bit (0 becomes 1, 1 becomes 0)
			and rdi, 1	; Ensure only the least significant bit remains
			or rax, rdi	; set the result bit in rax
			xor rax, rax	; clear rax to 0
			or rax, rdi 	; put the result in rax
		`

12. Memory-read
	Task:
		Place the value stored at 0x404000 into rax. Make sure the value in rax is the original value stored at 0x404000.
		
	Solution:
		`............
		............
		
		_start:
			mov rax, [ 0x404000]
			
		`


13. Memory-write
	Task:
		Place the value stored in rax to 0x404000
		
	Solution:
		`............
		............
		
		_start:
			mov [0x404000], rax
		`
		
14. Memory-increment
	Task:
		Please perform the following:

	    Place the value stored at 0x404000 into rax.
	    Increment the value stored at the address 0x404000 by 0x1337.

	Make sure the value in rax is the original value stored at 0x404000 and make sure that [0x404000] now has the incremented value.
	
	Solution:
	`.intel_syntax noprefix

	.global _start

	_start:
		mov rax, [0x404000]
		add qword ptr [0x404000],0x1337`
		
15. Byte-access
		Here is the breakdown of the names of memory sizes:

	    Quad Word = 8 Bytes = 64 bits
	    Double Word = 4 bytes = 32 bits
	    Word = 2 bytes = 16 bits
	    Byte = 1 byte = 8 bits

	In x86_64, you can access each of these sizes when dereferencing an address, just like using bigger or smaller register accesses:

	    mov al, [address] <=> moves the least significant byte from address to rax
	    mov ax, [address] <=> moves the least significant word from address to rax
	    mov eax, [address] <=> moves the least significant double word from address to rax
	    mov rax, [address] <=> moves the full quad word from address to rax


	Task:
		Please perform the following: Set rax to the byte at 0x404000.
		
	Solution:
		`...............
		...............
		
		_start:
			mov al, [0x404000]
		`
		
16. Memory-size-access
	Task:
		 Perform the following:

		    Set rax to the byte at 0x404000
		    Set rbx to the word at 0x404000
		    Set rcx to the double word at 0x404000
		    Set rdx to the quad word at 0x404000
	
	Solution:
		`...........
		..............
		
		_start:
			mov al, [0x404000]
			mov bx, [0x404000]
			mov ecx, [0x404000]
			mov rdx, [0x404000]
		`

17. Litle-Endian-write
	Task:
		The first address will be placed in rdi. The second will be placed in rsi.

		Using the earlier mentioned info, perform the following:

		    Set [rdi] = 0xdeadbeef00001337
		    Set [rsi] = 0xc0ffee0000

	Solution:
		`..........
		............
		
		_start:
			mov rax, 0xdeadbeef00001337
			mov [rdi], rax
			
			mov rax, 0xc0ffee0000
			mov [rsi], rax
		`

18. Memory-sum
	Task:
		Perform the following:

		    Load two consecutive quad words from the address stored in rdi.
		    Calculate the sum of the previous steps' quad words.
		    Store the sum at the address in rsi.
		    
	Solution:
		`.............
		...............
		
		_start:
			mov rax, [rdi]
			mov rdx, [rdi + 8]
			
			add rax, rdx
			
			mov [rsi], rax
		`

19. Stack-substraction
	Task:
		Using these instructions, take the top value of the stack, subtract rdi from it, then put it back.
		
	Solution:
		`..............
		................
		
		_start:
			pop rax
			sub rax, rdi
			push rax
		`
		
20. swap-stack-values
	Task:
		Using only the following instructions:

		    push
		    pop

		Swap values in rdi and rsi.
	
	Solution:
		`..........
		...........
		
		_start:
			push rdi
			push rsi
			pop rdi
			pop rsi
		`

21. Average-stack-values

		

