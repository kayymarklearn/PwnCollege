Now that you have the hang of very basic assembly, let's dive in and explore a few different instructions and some additional concepts! The Assembly Crash Course is a romp through a lot of different things you can do in assembly.

We will be using intel syntax for all our assembly code, so always use this prefix before your code;
	.intel_syntax noprefix
	.global _start
	_start:
	
We will assemble our code with;
	gcc -nostdlib -o prog prog.s
	
The program can be run with;
	./prog
after compilation.

You can disassemble your program with;
	objdump -M intel -d prog
	
Now to the challenges;

1. Set-register;
	Task: set the register, rdi to 0x1337
	Solution:
		`.intel_syntax noprefix

		.global _start

		_start:
		mov rdi, 0x1337 `

2. Set-multiple-registers:
	Task: Set the registers to the following;
		
    		rax = 0x1337
   		r12 = 0xCAFED00D1337BEEF
    		rsp = 0x31337

	Solution:
		`.intel_syntax noprefix
		.global _start

		_start:
		mov rax, 0x1337
		mov r12, 0xCAFED00D1337BEEF
		mov rsp, 0x31337 `
		
Let's learn some useful instructions before tackling the next challenges:
	a. add reg1, reg2 <=> reg1 += reg2 <=> reg1 = reg1 + reg2	# add 2 registers
	b. sub reg1, reg2 <=> reg1 -= reg2 <=> reg1 = reg1 - reg2	# sub 2 registers
	c. imul reg1, reg2 <=> reg1 *= reg2 <=> reg1 = reg1 * reg2 	# mul 2 registers
	NOTE: regX, can be replaced by a constant or a mem location, div is more complicated and will be discussed later.
With this knowledge, we'll tackle the next challenges.

3. add-to-registers
	Task: Add 0x331337 to rdi
	Solution:
		` .intel_syntax noprefix
		.global _start

		_start:

		add rdi, 0x331337`
		
4. linear-equation-registers
	Task: Compute, f(x) = mx + b, where;
		m = rdi, x = rsi, b = rdx
	
	Solution:
		`.intel_syntax noprefix
		.global _start

		_start:
		imul rdi, rsi
		add rdi, rdx
		mov rax, rdi `

DIVISION in x86 is more special than in normal math. Math here is called integer math, meaning every value is a whole number.
As an example: 10 / 3 = 3 in integer math.

Why?

Because 3.33 is rounded down to an integer.

The relevant instructions for this level are:

    mov rax, reg1
    div reg2

NOTE: div is a special instruction that can divide a 128-bit dividend by a 64-bit divisor while storing both the quotient and the remainder, using only one register as an operand.

How does this complex div instruction work and operate on a 128-bit dividend (which is twice as large as a register)?

For the instruction div reg, the following happens:

    rax = rdx:rax / reg
    rdx = remainder

rdx:rax means that rdx will be the upper 64-bits of the 128-bit dividend and rax will be the lower 64-bits of the 128-bit dividend.

You must be careful about what is in rdx and rax before you call div.

5. integer-division:
	Task:
		Compute the following:

    		speed = distance / time, where:
        	distance = rdi
        	time = rsi
        	speed = rax
        
        Solution:
        	`.intel_syntax noprefix
		.global _start

		_start:
		mov rax, rdi		# mov numerator (distance) into rax
		xor rdx, rdx		# clear rdx to prepare for division (upper 64 bits)
		div rsi`		# unsigned divide rdx:rax by rsi
		
		REMEMBER: Quotient (speed here) is in rax, remainder is in rdx.

6. modulo operation:
	Modulo is basically the remainder of a division operation.
	So 10 % 3, will return 1 (where % is the modulo operator).
	Note that the remainder of the div operation in x86 is stored in rdx.
	
	Task:
		Compute the following: rdi % rsi
		Place the value in rax.
	
	Solution:
		`.intel_syntax noprefix
		.global _start
		
		_start:
			mov rax, rdi
			xor rdx, rdx
			div rsi
			
			mov rax, rdx`	# Placing the remainder (which is in rdx) into rax.
			
7. set-upper-byte:
	Each register in x86_64 is 64 bits in size. 
	We can also access the lower bytes of each register using different register names.
	For example, the lower 32 bits of rax can be accessed using eax, the lower 16 bits using ax, and the lower 8 bits using al.

	MSB                                    LSB
	+----------------------------------------+
	|                   rax                  |
	+--------------------+-------------------+
		             |        eax        |
		             +---------+---------+
		                       |   ax    |
		                       +----+----+
		                       | ah | al |
		                       +----+----+

	Task:
		Using only one move instruction, please set the upper 8 bits of the ax register to 0x42.
		
	Solution:
		`.intel_syntax noprefix
		.global _start
		
		_start:
			mov ah, 0x42 # ax is a 32bit reg that has ah as upper bit and al as lower bit
			
8. Efficient modulo:
	We can use a math trick to optimize the modulo operator (%). Compilers use this trick a lot.

	If we have x % y, and y is a power of 2, such as 2^n, the result will be the lower n bits of x.

	Therefore, we can use the lower register byte access to efficiently implement modulo!
	
	Task:
		Compute the following:

		    rax = rdi % 256
		    rbx = rsi % 65536
		    
	Solution:
		`.intel_syntax noprefix
		.global _start

		mov rax, 0
		mov al, dil	; rax = rdi % 256, 256 = 2^8, so we move lowest 8 bit of rdi (dil) to al (lowest 8 bit of rax)
		
		mov rbx, 0
		mov bx, si	; rbx = rsi % 65536, 65536 = 2 ^16, so we move the lowest 16 bits.
		`

9. Byte-Extraction:
	
	IMPORTANT INFO:
		Shifting bits around in assembly is another interesting concept!

		x86 allows you to 'shift' bits around in a register.

		Take, for instance, al, the lowest 8 bits of rax.

		The value in al (in bits) is:

		rax = 10001010

		If we shift once to the left using the shl instruction:

		shl al, 1

		The new value is:

		al = 00010100

		Everything shifted to the left, and the highest bit fell off while a new 0 was added to the right side.

		You can use this to do special things to the bits you care about.

		Shifting has the nice side effect of doing quick multiplication (by 2) or division (by 2), and can also be used to compute modulo.	
		
		
		Here are the important instructions:

		    shl reg1, reg2 <=> Shift reg1 left by the amount in reg2
		    shr reg1, reg2 <=> Shift reg1 right by the amount in reg2
		    
	Task:
		Set rax to the 5th least significant byte of rdi.

		For example:

		rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |
		Set rax to the value of B4
		
	Solution:
		`.intel_syntax noprefix
		.global _start
		
		_start:
			shr rdi, 4
			shr rdi, 7
			mov rax, rdi
		'

Bitwise logic, performs comparisions between individual bits.
Here are some truth tables for reference:

    AND

    A | B | X
    ---+---+---
    0 | 0 | 0
    0 | 1 | 0
    1 | 0 | 0
    1 | 1 | 1

    OR

    A | B | X
    ---+---+---
    0 | 0 | 0
    0 | 1 | 1
    1 | 0 | 1
    1 | 1 | 1

    XOR

    A | B | X
    ---+---+---
    0 | 0 | 0
    0 | 1 | 1
    1 | 0 | 1
    1 | 1 | 0


	



		

